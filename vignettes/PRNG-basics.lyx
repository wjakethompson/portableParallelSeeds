#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
%\VignetteIndexEntry{PRNG-basics}
\usepackage{Sweavel}
\usepackage{graphicx}
\usepackage{color}

\usepackage{babel}
\usepackage[samesize]{cancel}



\usepackage{ifthen}

\makeatletter

\renewenvironment{figure}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{figure}

 }{%

   \@float{figure}[#1]%

 }%

 \centering

}{%

 \end@float

}

\renewenvironment{table}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{table}

 }{%

   \@float{table}[#1]%

 }%

 \centering

%  \setlength{\@tempdima}{\abovecaptionskip}%

%  \setlength{\abovecaptionskip}{\belowcaptionskip}%

% \setlength{\belowcaptionskip}{\@tempdima}%

}{%

 \end@float

}


%\usepackage{listings}
% Make ordinary listings look as if they come from Sweave
\lstset{tabsize=2, breaklines=true,style=Rstyle}

\def\Rcode{\lstinline[basicstyle=\ttfamily,keywordstyle={}]}

% In document Latex options:
\fvset{listparameters={\setlength{\topsep}{0em}}}
\def\Sweavesize{\scriptsize} 
\def\Rcolor{\color{black}} 
\def\Rbackground{\color[gray]{0.90}}

\usepackage{babel}

\usepackage[samesize]{cancel}

\usepackage{ifthen}

\usepackage{listings}% Make ordinary listings look as if they come from Sweave
\lstset{tabsize=2, breaklines=true, style=Rstyle}
\end_preamble
\options noae
\use_default_options false
\begin_modules
sweave
enumitem
foottoend
logicalmkup
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding T1
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Pseudo Random Generator Basics
\end_layout

\begin_layout Author
Paul E.
 Johnson <pauljohn @ ku.edu>
\end_layout

\begin_layout Abstract
This vignette accompanies the portableParallelSeeds package.
 It offers a detailed look at the generation of random numbers, providing
 some insights into terminology and usage of random number generators.
 
\end_layout

\begin_layout Standard
This note offers a brief review terminology and usage of random generators.
 
\end_layout

\begin_layout Standard
The design of replicable Monte Carlo simulations requires careful management
 of the sources of randomness.
 Researchers are generally aware of the need to specify a 
\begin_inset Quotes eld
\end_inset

seed
\begin_inset Quotes erd
\end_inset

 to initialize a simulation, and they are comfortable with the idea that
 they can draw 1000 numbers appear to be equivalent to a Normal (or some
 other distribution), but they are generally not aware of the foundations.
 While working on the portableParallelSeeds package for R, I became convinced
 that students need a slightly deeper understanding of random number generation.
 
\end_layout

\begin_layout Standard
The underlying process of random number generation is unnecessarily mysterious.
 
\end_layout

\begin_layout Standard
This became apparent while I was working with a graduate class to develop
 the portableParallelSeeds package.
 Most R users, like my students, do not want to know very much about where
 random numbers come from.
 
\end_layout

\begin_layout Section
Terminology
\end_layout

\begin_layout Standard
There is no such thing as a 
\begin_inset Quotes eld
\end_inset

random number generator.
\begin_inset Quotes erd
\end_inset

 But there are 
\series bold
pseudo random number generators 
\series default
(PRNGs).
 A PRNG generates a stream of numbers in which there is no apparent pattern.
 If an outside user can discern the pattern, then a generator is considered
 
\begin_inset Quotes eld
\end_inset

broken
\begin_inset Quotes erd
\end_inset

 and its use is discouraged.
 The output from each draw from a PRNG should, as much as possible, be indisting
uishable from an equally likely draw of all possible integers.
 There should be not cyclic repetitions or trends.
\end_layout

\begin_layout Standard
Simulated 
\series bold
statistical distributions
\series default
 are built on top of the output from PRNGS.
 Designing a function that converts PRNG output to simulated draws from
 a statistical distribution requires a great deal of care.
 Some distributions, like the uniform distribution, are easy to simulate,
 since the PRNG is supposed to create equally likely integers.
 Some distributions (e.g, the logistic) are almost as easy to derive, while
 for others (e.g., the gamma distribution) are very difficult.
 The normal distribution is a on the medium-high end of the difficulty scale.
 There are several competing proposals at this time, none of which appears
 to be superior to the others.
 
\end_layout

\begin_layout Section
The Difference between the 
\begin_inset Quotes eld
\end_inset

seed
\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

internal state
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Inside the PRNG, there is a vector of values: the 
\series bold
internal state
\series default
.
 The internal state is combined with mathematical formula that are used
 to emit the apparently random numbers.
 In PRNG research, it is common to refer to that internal state as the 
\series bold
seed
\series default
 of the PRNG.
 
\end_layout

\begin_layout Standard
The term 
\begin_inset Quotes eld
\end_inset

seed
\begin_inset Quotes erd
\end_inset

 is used differently by applied statistical researchers.
 To most researchers who are not specialized in PRNGs, a seed is an integer
 that is used to re-set a random number generator.
 This misunderstanding flows from mis-statements in the documentation for
 popular statistical programs.
 For example, the SAS Language Reference states, 
\begin_inset Quotes eld
\end_inset

Random-number functions and CALL routines generate streams of pseudo-random
 numbers from an initial starting point, called a seed, that either the
 user or the computer clock supplies
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citeyearpar
key "SASLang"

\end_inset

.
 
\end_layout

\begin_layout Standard
It would be more clear if computer software referred to these user input
 values as 
\begin_inset Quotes eld
\end_inset

intializing integers.
\begin_inset Quotes erd
\end_inset

 The seed, as we mentioned, is a vector of numbers that characterize the
 internal state of a dynamical process of a PRNG.
 An initializing integer launches that dynamical process.
 The seed--internal state--is actually a much more complicated thing.
\end_layout

\begin_layout Standard
In R, for example, 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=F, include=F>>=
\end_layout

\begin_layout Plain Layout

RNGkind("Mersenne-Twister")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The default PRNG in R is the Mersenne-Twister, commonly known as MT19937
 
\begin_inset CommandInset citation
LatexCommand citep
key "matsumoto1998"

\end_inset

.
 The Mersenne-Twister was proposed by 
\begin_inset CommandInset citation
LatexCommand citet
key "matsumoto1998"

\end_inset

 and, at the current time, it is considered a premier random generator for
 statistics.
 It is the default random generator in almost every statistical program
 (including R, SAS, Matlab, Mplus, among others).
 
\end_layout

\begin_layout Standard
The R internal variable 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|.Random.seed|
\end_layout

\end_inset

 is the place where the internal state of the stream is stored.
 This is the case whether one is using MT19937, or something else.
 In this example, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
s0
\end_layout

\end_inset

is a snapshot of the internal state.
 We inspect the first 12 values.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

s0 <- .Random.seed
\end_layout

\begin_layout Plain Layout

s0[1:12]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first two integer values are internal markers that R uses to remember
 where this random number stream has been.
 The rest of the numbers in the vector are, well, the internal state of
 the generator.
 Please take note of the fact that the second value is 624, which will be
 significant when we consider MT19937 in depth.
 Brave R users who run 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
s0
\end_layout

\end_inset

 will see that there are 624 integers after the number 624.
 
\end_layout

\begin_layout Subsection
MT19937's internal state
\end_layout

\begin_layout Standard
In order to understand the way R implements the various PRNGs, and thus
 the way portableParallelSeeds works, it is important to explore what happens
 to the internal state of the generator as we draw random numbers.
 
\end_layout

\begin_layout Standard
Since we began with the default, MT19937, we might as well work on that
 first.
 Suppose we draw one fresh value from a uniform distribution.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Take a quick look at the generator's internal state after that.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

s1 <- .Random.seed
\end_layout

\begin_layout Plain Layout

s1[1:10]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The interesting part is in the first two values.
 
\end_layout

\begin_layout Itemize
403.
 This is the R PRNG typology.
 The value 
\begin_inset Quotes eld
\end_inset

03
\begin_inset Quotes erd
\end_inset

 indicates that MT19937 is in use, while the value 
\begin_inset Quotes eld
\end_inset

4
\begin_inset Quotes erd
\end_inset

 means that the inversion method is used to simulate draws from a normal
 distribution.
 
\end_layout

\begin_layout Itemize
1.
 That's a counter.
 How many random values have been drawn from this particular vector? Only
 one.
 
\end_layout

\begin_layout Standard
Each time we draw another uniform random value, the generator's counter
 variable will be incremented by one.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

s2 <- .Random.seed
\end_layout

\begin_layout Plain Layout

s2[2]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that s2[2] is incremented by 1 unit.
 Now check a few more
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

s3 <- .Random.seed
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

s4 <- .Random.seed
\end_layout

\begin_layout Plain Layout

cbind(s1, s2, s3, s4)[1:12, ]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I'm only showing the first 12 elements, to save space, but there's nothing
 especially interesting about elements 13 through 626.
 Columns 13:626 stay the same until the counter in row 2 reaches 624, at
 which point all values in 3 through 626 are replaced.
 This is why the scheme created by 
\begin_inset CommandInset citation
LatexCommand citet
key "matsumoto1998"

\end_inset

 is so fast: it generates enough information to draw 624 random numbers
 in one calculation.
 
\end_layout

\begin_layout Standard
As soon as we draw more random numbers--enough to cause the 2nd variable
 to increment past 624--then the 
\emph on
whole vector
\emph default
 changes.
 I'll draw 620 more values.
 The internal state s5 is 
\begin_inset Quotes eld
\end_inset

on the brink
\begin_inset Quotes erd
\end_inset

 and one more random uniform value pushes it over the edge.
 The internal state s6 represents a wholesale update of the generator.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

invisible(runif(620))
\end_layout

\begin_layout Plain Layout

s5 <- .Random.seed
\end_layout

\begin_layout Plain Layout

invisible(runif(1))
\end_layout

\begin_layout Plain Layout

s5[2]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The counter has reached 624.
 When we draw one more number, the internal state will be replaced by a
 new set, and the counter will fall back to 1.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

s6 <- .Random.seed
\end_layout

\begin_layout Plain Layout

invisible(runif(1))
\end_layout

\begin_layout Plain Layout

s6[2]
\end_layout

\begin_layout Plain Layout

s7 <- .Random.seed
\end_layout

\begin_layout Plain Layout

invisible(runif(1))
\end_layout

\begin_layout Plain Layout

s7[2]
\end_layout

\begin_layout Plain Layout

s8 <- .Random.seed
\end_layout

\begin_layout Plain Layout

s8[2]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After the wholesale change between s5 and s6, another draw produces more
 
\begin_inset Quotes eld
\end_inset

business as usual.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

cbind(s1, s5, s6, s7, s8)[1:12, ]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset

Observe that the internal state of the generator in states s6, s7 and s8
 is not changing, except for the counter.
\end_layout

\begin_layout Standard
Like all R generators, the MT19937 generator can be re-set to a previous
 saved state.
 There are two ways to do this.
 One way is the somewhat restrictive function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|set.seed()|
\end_layout

\end_inset

.
 That translates an initializing integer into the 626 valued internal state
 vector of the generator (that's stored in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|.Random.seed|
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reinit1>>=
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

s9 <- .Random.seed
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can achieve the same effect by using the assign function to replace the
 current value of .Random.seed with a copy of a previously saved state, s0.
 I'll draw one uniform value and then inspect the internal state of the
 generator (compare s1, s9, and s10).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reinit2>>=
\end_layout

\begin_layout Plain Layout

assign(".Random.seed", s0, envir = .GlobalEnv)
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

s10 <- .Random.seed
\end_layout

\begin_layout Plain Layout

cbind(s1, s9, s10)[1:8, ]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reader should notice that after re-initializing the state of the random
 generator, we draw the exact same value from 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|runif(1)|
\end_layout

\end_inset

 and after that the state of the generator is the same in all of the cases
 being compared (s9 is the same as s10).
 
\end_layout

\begin_layout Standard
The MT19937 is a great generator with a very long repeat cycle.
 The cycle of values it provides will not begin to repeat itself until it
 generates 
\begin_inset Formula $2^{19937}$
\end_inset

 values.
 It performs very well in a series of tests of random number streams.
 
\end_layout

\begin_layout Standard
The only major shortcoming of MT19937 is that it does not work well in parallel
 programming.
 MT19937 can readily provide random numbers for 1000s of runs of a simulation
 on a single workstation, if they are executed one-after-the other.
 However, it is very difficult (maybe impossible) to systematically initialize
 MT19937 on many compute nodes in a cluster so that the random streams are
 not overlapping.
 One idea is to spawn separate MT19937 generators with slightly different
 internal parameters so that the streams they generate will differ (
\begin_inset CommandInset citation
LatexCommand citealp
key "mascagni_sprng:_2000"

\end_inset

; see also 
\begin_inset CommandInset citation
LatexCommand citealp
key "Matsumoto2000"

\end_inset

).
 For a variety of reasons, work on parallel computing with an emphasis on
 replication has tended to use a different PRNG, which is described next.
 
\end_layout

\begin_layout Subsection
CMRG, an alternative generator.
\end_layout

\begin_layout Standard
In parallel computing with R, the most widely used random generator is Pierre
 L'Ecuyer's combined multiple-recursive generator, or CMRG 
\begin_inset CommandInset citation
LatexCommand citep
key "lecuyer_good_1999"

\end_inset

.
\end_layout

\begin_layout Standard
R offers a number of pseudo random generators, but only one random generator
 can be active at a given moment.
 That restriction applies because the variable .Random.seed is used as the
 central co-ordinating piece.
 When the user asks for a uniform random number from some statistical distributi
on (such as 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
rnorm
\end_layout

\end_inset

 or 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
rgamma
\end_layout

\end_inset

), the R internal system scans the .Random.seed to find out which PRNG algorithm
 should be used and then the value of .Random.seed is passed on to the proper
 generator.
 
\end_layout

\begin_layout Standard
We ask R to use that generator by this command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<crmg1, include=T, eval=F>>=
\end_layout

\begin_layout Plain Layout

RNGkind("L'Ecuyer-CMRG")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That puts the value of .Random.seed to a proper condition in the global environmen
t.
 Any R function that depends on random numbers--to simulate random distributions
 or to initialize estimators--it will now draw from the CMRG using .Random.seed
 as its internal state.
 
\end_layout

\begin_layout Standard
Parallel computing in a cluster of separate systems pre-supposes the ability
 to draw separate, uncorrelated, non-overlapping random numbers on each
 system.
 In order to do that, we follow an approach that is referred to as the 
\begin_inset Quotes eld
\end_inset

many separate substreams
\begin_inset Quotes erd
\end_inset

 approach.
 The theory for this approach is elegant.
 Think of a really long vector of randomly generated integers.
 This vector is so long it is, well, practically infinite.
 It has more numbers than we would need for thousands of separate projects.
 If we divide this practically infinite vector into smaller pieces, then
 each piece can be treated as a separate random number stream.
 Because these separate vectors are drawn from the one really long vector
 of random numbers, then we have confidence that the separate substreams
 are not overlapping each other and are not correlated with each other.
 But we don't want to run a generator for a really long time so that we
 can find the subsections of the stream.
 That would require an impractically huge amount of storage.
 So, to implement the very simple, solid theory, we need a practical way
 to splice into a random vector, to find the initial states of each separate
 substream.
\end_layout

\begin_layout Standard
That sounds impossible, but a famous paper by 
\begin_inset CommandInset citation
LatexCommand citep
key "lecuyer_object-oriented_2002"

\end_inset

 showed that it can be done.
 
\begin_inset CommandInset citation
LatexCommand citeauthor
key "lecuyer_object-oriented_2002"

\end_inset

 demonstraed an algorithm that can 
\begin_inset Quotes eld
\end_inset

skip
\begin_inset Quotes erd
\end_inset

 to widely separated points in the long sequence of random draws.
 Most importantly, this is done 
\emph on
without actually generating the practically infinite series of values
\emph default
.
 In R version 2.14, the L'Ecuyer CMRG was included as one of the available
 generators.
 We can find the generator's internal state at far-apart positions.
 
\end_layout

\begin_layout Standard
Lets explore L'Ecuyer's CMRG generator, just as we explored MT19937.
 First, we tell R to change its default generator, and then we set the initial
 state and draw four values.
 We collect the internal state (.Random.seed) of the generator after each
 random uniform value is generated.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cmrg4>>=
\end_layout

\begin_layout Plain Layout

RNGkind("L'Ecuyer-CMRG")
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

t0 <- .Random.seed
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

t1 <- .Random.seed
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

t2 <- .Random.seed
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

t3 <- .Random.seed
\end_layout

\begin_layout Plain Layout

rnorm(1)
\end_layout

\begin_layout Plain Layout

t4 <- .Random.seed
\end_layout

\begin_layout Plain Layout

cbind(t1, t2, t3, t4)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note, we can display the whole state vector, it is not 626 elements long:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cmrg5>>=
\end_layout

\begin_layout Plain Layout

cbind(t1, t2, t3, t4)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset

Apparently, this generator's assigned number inside the R framework is 
\begin_inset Quotes eld
\end_inset

07
\begin_inset Quotes erd
\end_inset

 (the 
\begin_inset Quotes eld
\end_inset

4
\begin_inset Quotes erd
\end_inset

 still indicates that inversion is being used to simulate normal values).
 There are 6 integer numbers that characterize the state of the random generator.
 The state vector is thought of as 2 vectors of 3 elements each.
 Note that the state of the CMRG process does not include a counter variable
 comparable to the 2nd element in the MT19937's internal state.
 Each successive draw shifts the values in those vectors.
 
\end_layout

\begin_layout Standard
The procedure to skip ahead to the starting point of the next substream
 is implemented in the R function nextRNGStream, which is provided in R's
 parallel package.
 The state vectors, which can be used to re-initialize 5 separate random
 streams, are shown below.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

require(parallel) ## for nextRNGStream
\end_layout

\begin_layout Plain Layout

substreams <- vector("list", 5)
\end_layout

\begin_layout Plain Layout

substreams[[1]] <- t0
\end_layout

\begin_layout Plain Layout

substreams[[2]] <- nextRNGStream(t0)
\end_layout

\begin_layout Plain Layout

substreams[[3]] <- nextRNGStream(substreams[[2]])
\end_layout

\begin_layout Plain Layout

substreams[[4]] <- nextRNGStream(substreams[[3]])
\end_layout

\begin_layout Plain Layout

substreams[[5]] <- nextRNGStream(substreams[[4]])
\end_layout

\begin_layout Plain Layout

substreams
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because the internal states are stored as elements in the R list substreams,
 we can reset the random number generator to any position we prefer.
 This is the magic that makes portableParallelSeeds work properly.
\end_layout

\begin_layout Section
Replication Challenges
\end_layout

\begin_layout Standard
In the days when I was writing agent-based computer simulations in Objective-C
 and Java, we were constantly perplexed by the difficulty of producing exactly
 the same simulation from a particular initial condition.
 We wanted, for example, to generate characteristics for 100s or 1000s of
 separate agents, and then have them interact, and it frequently happened
 that simulation runs would differ.
 In all of the cases that I investigated carefully, the differences were
 caused by very slight differences in the sequences of random numbers that
 were drawn.
 Some of the typical 
\begin_inset Quotes eld
\end_inset

gotchas
\begin_inset Quotes erd
\end_inset

 that will affect Monte Carlo simulations are now discussed.
 
\end_layout

\begin_layout Standard
Before reading further, let me ask you a question.
 Do you expect that this
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F,echo=T>>=
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

x1 <- runif(10)
\end_layout

\begin_layout Plain Layout

x2 <- rnorm(10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
should create exactly the same random numbers as
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F,echo=T>>=
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

x2 <- rnorm(10)
\end_layout

\begin_layout Plain Layout

x1 <- runif(10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
?
\end_layout

\begin_layout Standard
It seems to most people that the answer should be 
\begin_inset Quotes eld
\end_inset

Yes.
 Obviously
\begin_inset Quotes erd
\end_inset

.
 But the answer is 
\begin_inset Quotes eld
\end_inset

No.
 Definitely
\begin_inset Quotes erd
\end_inset

.
 And now I want to explain why.
\end_layout

\begin_layout Subsection
Distributions draw differently from the PRNG device.
\end_layout

\begin_layout Standard
The R uniform distribution function 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
runif
\end_layout

\end_inset

 draws one number from the random number stream and it gives back one simulated
 normal random variate.
 The R normal distribution function 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
rnorm
\end_layout

\end_inset

 draws two values from the PRNG stream and it gives back one simulated variate.
 The gamma distribution generator 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
rgamma
\end_layout

\end_inset

 is unpredictable! Each function that simulates draws from a statistical
 distribution changes the stream in a way that alters the output of the
 other functions.
 
\end_layout

\begin_layout Standard
Here is a small example in which this problem might arise.
 We draw 3 collections of random numbers.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

x1 <- runif(10)
\end_layout

\begin_layout Plain Layout

x2 <- rpois(10, lambda=7)
\end_layout

\begin_layout Plain Layout

x3 <- runif(10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Researchers in our lab always want to experiment with variations.
 Somebody says 
\begin_inset Quotes eld
\end_inset

That second one should not be poisson! It should be normal.
\begin_inset Quotes erd
\end_inset

 So we change the variable 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
x2
\end_layout

\end_inset

 to draw from a normal distribution.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

y1 <- runif(10)
\end_layout

\begin_layout Plain Layout

y2 <- rnorm(10)
\end_layout

\begin_layout Plain Layout

y3 <- runif(10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I expect that x1 and y1 will be identical, and they are.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

identical(x1,y1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I know x2 and y2 will differ (the first is poisson, the second is normal).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

identical(x1,y1)
\end_layout

\begin_layout Plain Layout

identical(x2,y2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But I expected, falsely, that x3 and y3 would be the same.
 But they are not.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

identical(x3, y3)
\end_layout

\begin_layout Plain Layout

rbind(x3, y3)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Their values are not even remotely similar.
 If we then go on to make calculations and compare these two models, then
 our conclusions will be very confusing.
 We have exactly the same draws in the first part, but the draws in the
 third part of the experiment differ.
 That one little change, the replacement of a poisson with a normal variable,
 caused a wholesale change in y3 as well.
\end_layout

\begin_layout Standard
Why does this problem arise? The function rnorm() draws two values from
 the random generator, thus causing all of the uniform values in y3 to differ
 from x3.
 This is easiest to see with MT19937, since that generator offers us the
 counter variable in element 2.
 I will re-initialize the stream, and then draw some values.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm1>>=
\end_layout

\begin_layout Plain Layout

RNGkind("Mersenne-Twister")
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

s0 <- .Random.seed
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

s1 <- .Random.seed
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

s2 <- .Random.seed
\end_layout

\begin_layout Plain Layout

runif(1)
\end_layout

\begin_layout Plain Layout

s3 <- .Random.seed
\end_layout

\begin_layout Plain Layout

rnorm(1)
\end_layout

\begin_layout Plain Layout

s4 <- .Random.seed
\end_layout

\begin_layout Plain Layout

cbind(s0, s1, s2, s3, s4)[1:6, ]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Note that the counter jumps by one between s0 and s1, s1 and s2, and between
 s2 and s3.
 In those 3 cases, the uniform numbers are drawn.
 Note the counter jumps by two between s3 and s4.
\end_layout

\begin_layout Standard
With CMRG, this problem is more difficult to diagnose.
 As a result, when I'm developing a simulation, I'll often use MT19937 because
 I can see the number of draws against the PRNG, and then I'll change to
 the CMRG when it is time to parallelize the simulation.
 We can replicate the problem with CMRG, once we know what to look for.
 We force the generator back to the initial state and then draw five uniform
 random variables.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T, include=F>>=
\end_layout

\begin_layout Plain Layout

assign(".Random.seed", t1, envir=.GlobalEnv)
\end_layout

\begin_layout Plain Layout

u1 <- .Random.seed
\end_layout

\begin_layout Plain Layout

invisible(runif(1))
\end_layout

\begin_layout Plain Layout

u2 <- .Random.seed
\end_layout

\begin_layout Plain Layout

invisible(runif(1))
\end_layout

\begin_layout Plain Layout

u3 <- .Random.seed
\end_layout

\begin_layout Plain Layout

invisible(runif(1))
\end_layout

\begin_layout Plain Layout

u4 <- .Random.seed
\end_layout

\begin_layout Plain Layout

invisible(runif(1))
\end_layout

\begin_layout Plain Layout

u5 <- .Random.seed
\end_layout

\begin_layout Plain Layout

cbind(u1, u2, u3, u4, u5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The internal states are displayed.
 Note the state of the generator u5 is the same as t4 in the previous section,
 meaning that drawing 5 uniform random variables puts the CMRG into the
 same state that CMRG reaches when we draw 3 uniform values and 1 normal
 variable.
 
\end_layout

\begin_layout Standard
The situation becomes more confusing when random variables are generated
 by an accept/reject algorithm.
 If we draw several values from a gamma distributions, we note that MT19937's
 counter may change by 2, 3, or more steps.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

RNGkind("Mersenne-Twister")
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

invisible(rgamma(1, shape = 1)); v1 <- .Random.seed[1:4]
\end_layout

\begin_layout Plain Layout

invisible(rgamma(1, shape = 1)); v2 <- .Random.seed[1:4]
\end_layout

\begin_layout Plain Layout

invisible(rgamma(1, shape = 1)); v3 <- .Random.seed[1:4]
\end_layout

\begin_layout Plain Layout

invisible(rgamma(1, shape = 1)); v4 <- .Random.seed[1:4]
\end_layout

\begin_layout Plain Layout

invisible(rgamma(1, shape = 1)); v5 <- .Random.seed[1:4]
\end_layout

\begin_layout Plain Layout

invisible(rgamma(1, shape = 1)); v6 <- .Random.seed[1:4]
\end_layout

\begin_layout Plain Layout

cbind(v1, v2, v3, v4, v5, v6)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Most of the time, drawing a single gamma value uses just 2 or 3 numbers
 from the generator, but about 10 percent of the time more draws will be
 taken from the generator.
 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A routine generates 10,000 gamma values while tracking the number of values
 drawn from the random generator for each is included with portableParallelSeeds
 in the examples folder (gamma_draws.R).
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The main point in this section is that apparently harmless changes in the
 design of a program may disturb the random number stream, thus making it
 impossible to replicate the calculations that follow the disturbance.
 Anticipating this problem, it can be essential to have access to several
 separate streams within a given run in order to protect against accidents
 like this.
\end_layout

\begin_layout Standard
Many other functions in R may draw random values from the stream, thus throwing
 off the sequence that we might be depending on for replication.
 Many sorting algorithms draw random numbers, thus altering the stream for
 successive random number generation.
 While debugging a program, one might unwittlingly insert functions that
 exacerbate the problem of replicating draws from random distributions.
 If one is to be extra-careful on the replication of random number streams,
 it seems wise to keep a spare stream for every project and then switch
 the generator to use that spare stream, and then change back to the other
 streams when number that need to be replicated are drawn.
 
\end_layout

\begin_layout Subsection
Be cautious about mvrnorm.
\end_layout

\begin_layout Standard
The MASS package function mvrnorm() is very widely used to generate multivariate
 normal data.
 It creates one row of data for each sample requested.
 
\end_layout

\begin_layout Standard
I recently noticed a quirk while trying to replicate some results.
 Suppose we draw 10 rows, with 3 columns like so.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

require(MASS)
\end_layout

\begin_layout Plain Layout

RNGkind("L'Ecuyer-CMRG")
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

.Random.seed
\end_layout

\begin_layout Plain Layout

X0 <- MASS::mvrnorm(n = 10, mu = c(0,0,0), Sigma = diag(3))
\end_layout

\begin_layout Plain Layout

X0
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, again, before I show you the result, let me ask for your intuition.
 The previous draws 10 observations from a multivariate normal distribution.
 Suppose we find out we only need to draw 5 observations.
 Do you expect that the first 5 rows of output from this command
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F,echo=T>>=
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

X0 <- MASS::mvrnorm(n = 5, mu = c(0,0,0), Sigma = diag(3))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will be the same as the first 5 rows of X0?
\end_layout

\begin_layout Standard
I thought the answer would be yes.
 If we are stopping 5 rows early, how can it be reasonable to expect the
 first 5 rows to change? I believed this would receive the first 5 rows
 of X0.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

.Random.seed
\end_layout

\begin_layout Plain Layout

X1 <- MASS::mvrnorm(n = 5, mu = c(0,0,0), Sigma = diag(3))
\end_layout

\begin_layout Plain Layout

X1
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And I had hoped, in vain, that if I drew a larger sample, that the first
 10 observations would match matrix X0.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

.Random.seed
\end_layout

\begin_layout Plain Layout

X2 <- MASS::mvrnorm(n = 15, mu = c(0,0,0), Sigma = diag(3))
\end_layout

\begin_layout Plain Layout

X2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is an unsatisfactory situation, of course.
 The first observations in the third column are the same in all three sets,
 while the rest differ.
 In a simulation exercise, this would have odd effects on our understanding
 of the effects of re-sampling and changes in sample size.
\end_layout

\begin_layout Standard
Only a small change in the mvrnorm code is required to solve this problem.
 Packaged with parallelPortableSeeds one finds a new version of mvrnorm
 that has better results, at least in terms of replication:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(portableParallelSeeds)
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

Y0 <- rockchalk::mvrnorm(n=10, mu = c(0,0,0), Sigma = diag(3))
\end_layout

\begin_layout Plain Layout

Y0
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

Y1 <- rockchalk::mvrnorm(n=5, mu = c(0,0,0), Sigma = diag(3))
\end_layout

\begin_layout Plain Layout

Y1
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

.Random.seed
\end_layout

\begin_layout Plain Layout

rnorm(1)
\end_layout

\begin_layout Plain Layout

Y2 <- rockchalk::mvrnorm(n=15, mu = c(0,0,0), Sigma = diag(3))
\end_layout

\begin_layout Plain Layout

Y2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
theendnotes{}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "pps"
options "apsr"

\end_inset


\end_layout

\end_body
\end_document
