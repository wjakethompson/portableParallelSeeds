#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
%\VignetteIndexEntry{pps}

\usepackage{Sweavel}
\usepackage{graphicx}
\usepackage{color}

\usepackage{babel}
\usepackage[samesize]{cancel}

\usepackage{ifthen}

\makeatletter

\renewenvironment{figure}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{figure}

 }{%

   \@float{figure}[#1]%

 }%

\centering

}{%

 \end@float

}

\renewenvironment{table}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{table}

 }{%

   \@float{table}[#1]%

 }%

 \centering

%  \setlength{\@tempdima}{\abovecaptionskip}%

%  \setlength{\abovecaptionskip}{\belowcaptionskip}%

% \setlength{\belowcaptionskip}{\@tempdima}%

}{%

 \end@float

}


%\usepackage{listings}
% Make ordinary listings look as if they come from Sweave
\lstset{tabsize=2, breaklines=true,style=Rstyle}

\def\Rcode{\lstinline[basicstyle=\ttfamily,keywordstyle={}]}

% In document Latex options:
\fvset{listparameters={\setlength{\topsep}{0em}}}
\def\Sweavesize{\scriptsize} 
\def\Rcolor{\color{black}} 
\def\Rbackground{\color[gray]{0.90}}

\usepackage{babel}

\usepackage[samesize]{cancel}

\usepackage{ifthen}

\usepackage{listings}% Make ordinary listings look as if they come from Sweave
\lstset{tabsize=2, breaklines=true, style=Rstyle}
\end_preamble
\options noae
\use_default_options false
\begin_modules
sweave
enumitem
foottoend
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding T1
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Portable Parallel Seeds 
\end_layout

\begin_layout Author
Paul E.
 Johnson <pauljohn @ ku.edu>
\end_layout

\begin_layout Abstract
The R package portableParallelSeeds implements one method of managing random
 streams for batches of simulations.
 It is designed so that separate runs can be replicated exactly, in the
 sense proposed by 
\begin_inset CommandInset citation
LatexCommand citet
key "chambers_software_2008"

\end_inset

.
 Using the 
\begin_inset Quotes eld
\end_inset

many separate substreams
\begin_inset Quotes erd
\end_inset

 made possible by the CMRG random generator (as proposed by 
\begin_inset CommandInset citation
LatexCommand citealp
key "lecuyer_object-oriented_2002"

\end_inset

), we first create a large collection of initial states for many random
 streams, and then make those streams available to simulation runs.
 The random number streams for each separate run of a simulation are thus
 properly initialized.
 The framework allows one to run a simulation in a single workstation (iterative
ly) or on a cluster computer (parallel) and obtain the same results.
 It is also possible to select particular runs from a batch and re-start
 them for closer inspection.
 This approach allows for each separate run to depend on several separate
 streams of random numbers and it offers a method for changing among the
 random streams.
\end_layout

\begin_layout Standard
The portableParallelSeeds package for R proposes a simple, yet powerful,
 method for replicating simulations in a way that is valid across hardware
 types and operating systems.
 It facilitates the work of researchers who need to run a series of simulations,
 either on a desktop workstation or in a cluster of many separate computers.
 The approach proposed here allows the precise replication of the whole
 batch of runs, whether run in serial or parallel, but it has two special
 features that are not easily available elsewhere.
 First, any particular run of the model may be re-created, in isolation
 from the rest of the runs.
 Second, each particular run can be initialized with several separate streams
 of random numbers, thus making some simulation designs easier to implement.
 One can, for example, draw on two separate streams to initialize data for
 1000 students and 50 teachers, and then draw random values from a third
 stream, and then turn back to the first stream to draw data for 50 more
 students from the same generator that generated the first batch of students.
 Thus, data for the same 1050 students would be obtained, whether they are
 drawn in two phases or in one continuous series of random draws.
\end_layout

\begin_layout Standard
The approach blends ideas about seed management from 
\begin_inset CommandInset citation
LatexCommand citet
key "chambers_software_2008"

\end_inset

 (as implemented in the R package SoDA, Chambers 
\begin_inset CommandInset citation
LatexCommand citeyear
key "chambers_soda:_2012"

\end_inset

) with ideas from the R package snowFT (Sevcikova and Rossini 
\begin_inset CommandInset citation
LatexCommand citeyear
key "snowFT"

\end_inset

).
 Chambers proposes a method of recording the random generator's state that
 works well in simulations that run on a single piece of hardware, but it
 does not generalize directly to a cluster computing framework in which
 simulation runs begin separately on many separate nodes.
 The framework introduced in snowFT initializes each compute node with its
 own random seed, but does not separately initialize each run of the model.
 The plan used in portableParallelSeeds addresses these shortcomings.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
In statistical research, it is now common to propose an estimator and then
 apply it to 1000s of simulated data sets in order to ascertain the sampling
 distribution (for a review, see Johnson, Forthcoming).
 One of the practical problems is to manage the insertion of randomness
 into the analysis.
 
\end_layout

\begin_layout Standard
Researchers face a variety of practical challenges in the management of
 these simulations.
 It is vital that each simulation exercise be replicatable, even in its
 very fine-grained details 
\begin_inset CommandInset citation
LatexCommand citep
key "chambers_software_2008"

\end_inset

.
 That is to say, in order to feel confident in the results of a simulation
 exercise, we need to be able to re-generate its runs exactly, not just
 on average.
 Suppose we conduct 2000 repetitions (runs) in a batch of simulations.
 We should be able to repeat the whole batch, exactly, and we should also
 be able to repeat individual part of the exercise.
 The simulated random values drawn for the 1324rd line of a data structure
 should be the same whether we re-start a project on a cluster computer
 or in a desktop workstation.
 If one accidentally collects the same random numbers for two variables
 that are expected to differ, one may mistakenly conclude that there is
 no difference to be found.
 On the other hand, if one accidentally draws numbers that differ, when
 the logic indicates that they ought to be exactly the same, then one will
 mistakenly conclude that something important has changed.
 The tools offered in portableParallelSeeds will help Monte Carlo studies
 avoid some of those dangers.
 
\end_layout

\begin_layout Subsection
A Quick For Loop Example
\end_layout

\begin_layout Standard
Because the discussion might seem intimidating to newcomers (and overflowing
 with jargon), lets begin with the simple use case.
 A researcher wants to run a Monte Carlo calculation 1000 times.
 Because each of these simulations might have some abnormal result, it is
 important that one must be able to pick a particular run, for example 232,
 and re-initialize it exactly.
 The following creates a seed collection called projSeeds and then the for
 loop accesses these seeds, one after the other.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, echo=F>>=
\end_layout

\begin_layout Plain Layout

options(device = pdf)
\end_layout

\begin_layout Plain Layout

options(width=160, prompt=" ", continue="  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE) 
\end_layout

\begin_layout Plain Layout

##options(SweaveHooks=list(fig=function() par(mar=pjmar, ps=10)))
\end_layout

\begin_layout Plain Layout

##pdf.options(onefile=F,family="Times",pointsize=10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(portableParallelSeeds)
\end_layout

\begin_layout Plain Layout

projSeeds <- seedCreator(1000, 3, seed = 232323)
\end_layout

\begin_layout Plain Layout

x1 <- vector(1000, mode = "numeric") 
\end_layout

\begin_layout Plain Layout

for(i in 1:1000) { 
\end_layout

\begin_layout Plain Layout

    initPortableStreams(projSeeds, run = i)
\end_layout

\begin_layout Plain Layout

    x1[i] <- mean(rnorm(100))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now suppose the researcher notices that one simulation is somehow unusual.
 Perhaps a histogram reveals that one simulation generates a result which
 appears to be an outlier.
 Perhaps the researcher will be interested to find out more about that one
 case.
 For example, she finds the lowest average,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

lowest <- which.max(x1); x1[lowest]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To more carefully inspect the lowest simulation, it is possible to ask for
 just that one run, and re-start it from an identical initial point.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

initPortableStreams(projSeeds, run = lowest)
\end_layout

\begin_layout Plain Layout

x1.lowest <- rnorm(100)
\end_layout

\begin_layout Plain Layout

(x1.lowest.mean <- mean(x1.lowest))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the calculated mean is identical to the value from the previous
 simulation.
 This is not a very interesting simulation, of course, but the main idea
 should be clear enough.
 One can step into the batch of models and re-start one run from a position
 that exactly replicates the initial trouble case.
 
\end_layout

\begin_layout Standard
Finally, suppose one wanted to re-run a whole batch of simulations from
 an identical spot.
 Perhaps we add more elaborate calculations, drawing additional observations
 from the random number stream.
 We need to be sure we subject this new, enhanced procedure to an identical
 sample.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x2 <- vector(1000, mode = "numeric") 
\end_layout

\begin_layout Plain Layout

for(i in 1:1000) { 
\end_layout

\begin_layout Plain Layout

    initPortableStreams(projSeeds, run = i, verbose = FALSE)
\end_layout

\begin_layout Plain Layout

    x2[i] <- mean(rnorm(100))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

    identical(x1, x2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We confirm, then, it is possible to re-initialize the random generator's
 stream so as to re-create the same results.
 
\end_layout

\begin_layout Subsection
Runs, streams: the portableParallelSeeds approach
\end_layout

\begin_layout Standard
A 
\series bold
run
\series default
 is an isolated series of calculations that begins in a pre-determined state.
 A random number 
\series bold
stream
\series default
, which is created by a pseudo-random number generator, is an identical
 sequence of values obtained by repeated calls on the generator.
 (A PRNG is not a 
\begin_inset Quotes eld
\end_inset

random
\begin_inset Quotes erd
\end_inset

 sequence in the colloquial sense.
 It is rather a sequence that is unpredictable to one who is not privy to
 the initializing state of the random stream.) Experimental runs differ because
 each begins in a different state.
 The draws from the generator are uncorrelated and do not have repetitive
 patterns.
\end_layout

\begin_layout Standard
The design of functions that use random numbers in R is a little bit tricky
 because all generators use to a single state variable called 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|.Random.seed|
\end_layout

\end_inset

 that is stored in the global environment of the R session.
 After each draw from the random generator, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|.Random.seed|
\end_layout

\end_inset

 is updated inside the R global environment.
 As mentioned in Gentleman, 
\begin_inset Quotes eld
\end_inset

The decision to have these [random generator] functions manipulate a global
 variable, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|.Random.seed|
\end_layout

\end_inset

, is slightly unfortunate as it makes it somewhat more difficult to manage
 several different random number streams simultaneously
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset citation
LatexCommand citealp
after "p. 201"
key "gentleman_r_2008"

\end_inset

).
 
\end_layout

\begin_layout Standard
The portableParallelSeeds package finesses a solution to that limitation
 in the following way.
 Information for several separate streams resides in memory.
 Random number draws continue to pull from a stream until the user asks
 R to start drawing from a different stream.
 Techincally, beneath the surface, we are swapping a different obect in
 place of R's 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|.Random.seed|
\end_layout

\end_inset

 when we intend to draw from a particular stream.
 This solution is not technically challenging, but it was somewhat difficult
 to package in a way that will be easy to use and trouble free for most
 users (see the function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|useStream()|
\end_layout

\end_inset

 for information about how to select among the random number streams).
 
\end_layout

\begin_layout Subsection
Runs, streams: the portableParallelSeeds approach
\end_layout

\begin_layout Standard
Step 1.
 Create a Collection of Initializing States for Random Number Generators.
\end_layout

\begin_layout Standard
Run the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|seedCreator()|
\end_layout

\end_inset

 function to create initializing information for a a given number of runs
 (and streams within each run).
 The object can reside in memory, but we generally recommend that users
 should specify the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|file|
\end_layout

\end_inset

 argument so that a copy of the information is saved in a physical file.
 The streams can be stored in a file and transported among systems so that
 a simulation can be re-started on various operating systems.
 
\end_layout

\begin_layout Standard
It may be helpful to think of the collection of initializing states as a
 matrix that has one row for each anticipated run of the model.
 Within each row of this matrix, there will be information to initialize
 one or more separate streams.
 A sketch of this initializing matrix is offered in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Initial-States"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
run
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stream 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stream 2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stream 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000,1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000,2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2000,3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Initial-States"

\end_inset

Matrix of Initializing States
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The creation of this set of initial random stream states is handled by the
 function 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|seedCreator()|
\end_layout

\end_inset

.
 That function will create seeds for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|nReps|
\end_layout

\end_inset

 separate runs, with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|streamsPerRep|
\end_layout

\end_inset

 separate random stream initializers for each run.
 The S3 class of that object is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|portableSeeds|
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Step 2.
 Design a function that isolates calculations for each run, and call it
 over and over.
\end_layout

\begin_layout Standard
Among the first actions within this function should be the establishment
 of the replicable random number streams.
 Basically, we simply take the initializing states from the seed warehouse
 and make them available in an R environment called 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|.pps|
\end_layout

\end_inset

.
 The function used most commonly for that, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|initPortableStreams()|
\end_layout

\end_inset

 is used as follows: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|initPortableStreams(projSeeds, run = i)|
\end_layout

\end_inset

.
 That will take an entire collection of seeds 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|projSeeds|
\end_layout

\end_inset

 into memory and then it will set the i'th one as the current set of streams.
 In an earlier version of this package, this was viewed as a two step process,
 one would select a row from the seed warehouse and then set it in place.
 That approach, called 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|setSeedCollection|
\end_layout

\end_inset

, can still be used.
 The syntax would be 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|setSeedCollection(projSeeds[i])|
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
A simulation program should have a function that orchestrates one 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 of calculations.
 If that function is called, for example, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|conductOneRun()|
\end_layout

\end_inset

, then the first piece of business in that function will be to re-set the
 set of random generator states.
 For example, given a run number and a collection of seeds, the work of
 initializing the simulation can be passed along to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Rcode|initPortableStreams()|
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F, include=T>>=
\end_layout

\begin_layout Plain Layout

conductOneRun <- function(run, streamSet, a, b, c, d){
\end_layout

\begin_layout Plain Layout

    initPortableStreams(projSeeds = streamSet, run = run, verbose = FALSE)
\end_layout

\begin_layout Plain Layout

    ## simulation calculations based on parameters a, b, c, and d
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the initializing states are saved in a file, then re-starting the process
 on any computer running R will re-generate the same simulation because
 the R Core Team (2014) has taken great effort to assure us that saved R
 files can be transferred from one type of hardware to another.
 
\end_layout

\begin_layout Subsection
Benefits of this Approach
\end_layout

\begin_layout Standard
The run-level initialization of random streams proposed here has several
 benefits.
 
\end_layout

\begin_layout Standard
Benefit 1.
 We get the same results for each individual run, whether the exercise is
 conducted on a workstation (in a serial process) or on compute clusters
 of various sizes.
 
\end_layout

\begin_layout Standard
By comparison, this is not possible with snowFT
\begin_inset CommandInset citation
LatexCommand citep
key "snowFT"

\end_inset

.
 The approach in snowFT will initialize the compute nodes, but then repeatedly
 assign jobs to the nodes without re-setting the random streams.
 This will assure that a whole batch of simulations can be replicated on
 that particular hardware setup, but it does not assure replication on clusters
 of different sizes.
 If we have a cluster with 5 machines, each can be predictably initialized,
 and then the 1000 simulation runs will be assigned among the 5 nodes, one
 after the other.
 We cannot obtain the same result in a cluster with 10 nodes, however.
 We initialize 10 machines and the 1000 runs are assigned among them.
 The random streams assigned for runs that are assigned to machines 6 through
 10 will be unique, so comparison of the runs against the first batch is
 impossible.
 The random streams used, for example, on the 6th run, will differ.
 
\end_layout

\begin_layout Standard
Benefit 2.
 Get the same results, even when a load balancing assignment of runs is
 used.
\end_layout

\begin_layout Standard
A load balancing algorithm monitors the compute nodes and sends the next
 assignment to the first available compute node.
 This may accelerate computations, but it plays havoc with replication.
 If 1000 runs are to be divided among 10 nodes, and are assigned in order
 to the same nodes, then the random number streams set on each node will
 remain in sequence across all of the runs.
 However, if we use a load balancing algorithm, then the jobs are not necessaril
y assigned to the same nodes on repeated runs.
 The presence of other programs running in a compute node or network traffic
 might slow down the completion of calculations, causing the node to 
\begin_inset Quotes eld
\end_inset

miss its spot in line,
\begin_inset Quotes erd
\end_inset

 thus altering the assignment of all future runs among nodes.
 As a result, when a load balancing algorithm is used, replication of results
 for any particular run appears to be extremely unlikely, even if we always
 have access to the same number of nodes.
\end_layout

\begin_layout Standard
Benefit 3.
 Isolate runs and investigate them in detail.
\end_layout

\begin_layout Standard
In the process of exploring a model, it may be that some simulation runs
 are problematic.
 The researcher wants to know what's wrong, which usually involves re-starting
 the simulation and then exploring it interactively.
 Because each separate run begins with a set of saved random generator states,
 accurate replication is possible.
\end_layout

\begin_layout Standard
Because the approach proposed here allows each simulation to depend on several
 separate streams of randomness, the researcher has much more flexibility
 in conducting this investigation.
 For example, the 
\begin_inset Quotes eld
\end_inset

replication part
\begin_inset Quotes erd
\end_inset

 of the simulation might be restricted to draw from stream 1, while the
 researcher can change to stream 2 to draw more random values without changing
 the values that will be offered by stream 1 in the remainder of the simulation.
 This prevents gratuitous changes in simulated values from triggering sequence
 of unpredictable changes in simulation results.
\end_layout

\begin_layout Standard
Benefit 4.
 Isolate sources of randomness.
 
\end_layout

\begin_layout Standard
The approach proposed here can create several random streams for use within
 each run.
 Furthermore, each of these streams can be re-initialized at any point in
 the simulation run.
 This capability will help to address some problems that arise in applied
 research projects.
 It often happens that projects will ask a question about the effect of
 changing the sample size, for example, and they will draw completely fresh
 samples of size N and N+k, whereas they ought to draw exactly the same
 sample for the first N observations, and then draw k fresh observations
 after that.
 Otherwise, the effect of adding the k additional observations is confounded
 with the entire replacement of the original N observations.
 Because portableParallelSeeds offers several separate streams, and each
 can be re-set at any time, the correct implementation is more likely to
 be achieved.
\end_layout

\begin_layout Standard
There are other scenarios in which the separate streams may be valuable.
 A project designer might conceptualize a single run as a family of small
 variations on a theme.
 Within each re-start in the family, several variables need to be replicated
 exactly, while others must be new.
 Because several streams are available, this can be managed easily.
\end_layout

\begin_layout Standard
The several separate streams are not absolutely necessary, but they will
 make it easier to isolate sources of change in a project.
 Drawing a single number from a shared random generator will put all of
 the following draws 
\begin_inset Quotes eld
\end_inset

out of sequence
\begin_inset Quotes erd
\end_inset

 and make replication of succeeding calculations impossible.
 It makes sense to segregate those calculations so that they draw from a
 separate random generator stream.
 
\end_layout

\begin_layout Section
Example Usage of portableParallelSeeds
\end_layout

\begin_layout Standard
The following uses seedCreator to generate initializing states for 1000
 simulation runs.
 In each of them we allow for three streams.
 The collection of random generator states is returned as an R object projSeeds,
 but it is also written on disk in a file called 
\begin_inset Quotes eld
\end_inset

fruits.rds
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(portableParallelSeeds)
\end_layout

\begin_layout Plain Layout

projSeeds <- seedCreator(1000, 3, seed = 123456, file = "fruits.rds")
\end_layout

\begin_layout Plain Layout

A1 <- projSeeds[[787]]
\end_layout

\begin_layout Plain Layout

A1 ## shows states of 3 generators for run 787
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For no particular reason, I elected to explore the internal states (the
 
\begin_inset Quotes eld
\end_inset

seeds
\begin_inset Quotes erd
\end_inset

) saved for run 787 in this example.
 We first check that the initPortableStreams() function can receive the
 collection of initializing information and re-generate the streams for
 run 787.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

initPortableStreams(projSeeds, run = 787, verbose = TRUE)
\end_layout

\begin_layout Plain Layout

.Random.seed
\end_layout

\begin_layout Plain Layout

getCurrentStream()
\end_layout

\begin_layout Plain Layout

runif(4)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, verify that if we read the file 
\begin_inset Quotes eld
\end_inset

fruits.rds
\begin_inset Quotes erd
\end_inset

, we can obtain the exact same set of initializing states for run 787.
 Note that the 4 random uniform values that are drawn exactly match the
 4 values drawn in the previous code section.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

myFruitySeeds <- readRDS("fruits.rds")
\end_layout

\begin_layout Plain Layout

B1 <- myFruitySeeds[[787]]
\end_layout

\begin_layout Plain Layout

identical(A1, B1) # check
\end_layout

\begin_layout Plain Layout

initPortableStreams("fruits.rds", run=787)
\end_layout

\begin_layout Plain Layout

.Random.seed
\end_layout

\begin_layout Plain Layout

runif(4)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That should be sufficient to satisfy our curiosity, a more elaborate test
 is offered next.
\end_layout

\begin_layout Standard
Step 2 in the simulation process is the creation of a function to conduct
 one single run of the simulation exercise.
 This function draws N normal variables from stream 1, some poisson variates
 from stream 2, then returns to stream 1 to draw another normal observation.
 We will want to be sure that the N+1 normal values that are drawn in this
 exercise are the exact same normals that we would draw if we took N+1 values
 consecutively from stream 1.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

runOneSimulation <- function(run, streamsource, N, m, sd){
\end_layout

\begin_layout Plain Layout

    initPortableStreams(streamsource, run = run, verbose= FALSE)
\end_layout

\begin_layout Plain Layout

    datX <- rnorm(N, mean = m, sd = sd)
\end_layout

\begin_layout Plain Layout

    datXmean <- mean(datX)
\end_layout

\begin_layout Plain Layout

    useStream(2)
\end_layout

\begin_layout Plain Layout

    datY <- rpois(N, lambda = m)
\end_layout

\begin_layout Plain Layout

    datYmean <- mean(datY)
\end_layout

\begin_layout Plain Layout

    useStream(1)
\end_layout

\begin_layout Plain Layout

    datXplusOne <- rnorm(1, mean = m, sd = sd)
\end_layout

\begin_layout Plain Layout

    ## Should be N+1'th element from first stream
\end_layout

\begin_layout Plain Layout

    c("datXmean" = datXmean, "datYmean" = datYmean, "datXplusOne" = datXplusOne)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now we test the framework in various ways, running 1000 simulations with
 each approach.
 Note the objects serial1, serial2, and serial3 are identical.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

## Give seed collection object to each simulation, let each pick desired
 seed
\end_layout

\begin_layout Plain Layout

serial1 <- lapply(1:1000, runOneSimulation, projSeeds, N=800, m = 14, sd
 = 10.1)
\end_layout

\begin_layout Plain Layout

## Re-load the seed object, then give to simulations
\end_layout

\begin_layout Plain Layout

fruits2 <- readRDS("fruits.rds")
\end_layout

\begin_layout Plain Layout

serial2 <- lapply(1:1000, runOneSimulation, fruits2, N=800, m = 14, sd =
 10.1)
\end_layout

\begin_layout Plain Layout

## Re-load file separately in each run (is slower)
\end_layout

\begin_layout Plain Layout

serial3 <- lapply(1:1000, runOneSimulation, "fruits.rds", N = 800, m = 14,
 sd=10.1)
\end_layout

\begin_layout Plain Layout

identical(serial1, serial2)
\end_layout

\begin_layout Plain Layout

identical(serial1, serial3)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, lets check the N+1 random normal values.
 We need to be sure that the 801'th random normal from stream 1 is equal
 to the 3'rd element in the returned vector.
 Lets check run 912.
 First, re-initialize the run, and then draw 801 new values from the normal
 generator (with the default stream 1).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

initPortableStreams("fruits.rds", run = 912, verbose = FALSE)
\end_layout

\begin_layout Plain Layout

.Random.seed
\end_layout

\begin_layout Plain Layout

X801 <- rnorm(801, m=14, sd = 10.1)
\end_layout

\begin_layout Plain Layout

X801[801]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
'The value displayed in variable X801[801] should be identical to the third
 element in the returned value that was saved in the batch of simulations.
 Observe
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

serial1[[912]]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Bingo.
 The numbers match.
 We can draw understandably replicatable streams of random numbers, whether
 we draw 800, switch to a different stream, and then change back to draw
 another, and obtain the same result if we just draw 801 in one block.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F>>=
\end_layout

\begin_layout Plain Layout

unlink("fruits.rds") #delete file
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
## I'd like to run this to demonstrate multi-core compatability, but
\end_layout

\begin_layout Plain Layout
## problems with mclapply on Linux (where tclck is loaded) prevent
\end_layout

\begin_layout Plain Layout
## me from expecting to to run on all systems.
 So I'll comment it out
\end_layout

\begin_layout Plain Layout
## for now.
\end_layout

\begin_layout Plain Layout
## require(parallel)
\end_layout

\begin_layout Plain Layout
## mc1 <- mclapply(1:1000, runOneSimulation, projSeeds, N = 800, m = 14,
 sd=10.1, mc.cores=3)
\end_layout

\begin_layout Plain Layout
## identical(mc1, serial1)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Frequently Asked Questions
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
This paper describes an R package called portableParallelSeeds.
 The package provides functions that can generate a seed collection which
 can be put to use in a series of simulation runs.
 The approach described here is based on the re-initialization of individual
 runs, and thus it will work whether the simulations are conducted on a
 single computer or in a cluster computer.
\end_layout

\begin_layout Standard
The tools provided are intended to help with situations like the following.
\end_layout

\begin_layout Standard
Problem 1.
 I scripted up 1000 R runs and need high quality, unique, replicable random
 streams for each one.
 Each simulation runs separately, but I need to be confident their streams
 are not correlated or overlapping.
 I need to feel confident that the results will be the same, whether or
 not I run these in a cluster with 4 computers, or 4000 computers.
\end_layout

\begin_layout Standard
Problem 2.
 For replication, I need to be able to select any run, and restart it exactly
 as it was.
 That means I need pretty good record keeping along with a simple approach
 for bringing simulations back to life.
 
\end_layout

\begin_layout Standard
Question: Why is this better than the simple old approach of setting the
 generator's initial state within each run with a formula like this.
\end_layout

\begin_layout Standard
set.seed(2345 + 10 * run)
\end_layout

\begin_layout Standard
Answer: That does allow replication, but it does not assure that each run
 uses non-overlapping random number streams.
 It offers absolutely no assurance whatsoever that the runs are actually
 non-redundant.
\end_layout

\begin_layout Standard
Nevertheless, it is a method that is widely used and recommended by some
 visible HOWTO guides.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "pps"
options "apsr"

\end_inset


\end_layout

\end_body
\end_document
